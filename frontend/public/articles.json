[
  {
    "id": 1,
    "title": "Stacks Explained: A Comprehensive Guide",
    "description": "Learn the fundamentals of stacks, a crucial data structure used for managing data in a LIFO (Last In, First Out) manner, along with practical examples in C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-09-24",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, a stack can be implemented using the Standard Template Library (STL). The stack is a linear data structure that follows LIFO (Last In First Out) principle. The major operations on a stack are push, pop, and top.",
      "Python": "In Python, the stack can be implemented using lists. Lists in Python provide the functionality of a dynamic array, but they can also be used to implement a stack by using the append() and pop() methods."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the Stack class. It initializes an empty stack with a size of 0 and sets the head to nullptr.",
        "destructor": "This is the destructor for the Stack class. It ensures that all allocated memory is freed when the stack is no longer needed by popping all the elements from the stack.",
        "push": "The push function adds a new element to the top of the stack. It creates a new node and links it as the new head of the stack.",
        "pop": "The pop function removes the top element from the stack. If the stack is empty, it throws an error. Otherwise, it returns the top value and adjusts the head to point to the previous element.",
        "isEmpty": "The isEmpty function checks whether the stack is empty by verifying if the head is nullptr.",
        "main": "This is a sample main function that demonstrates how to use the Stack class by pushing elements onto the stack and then popping them off."
      },
      "Python": {
        "constructor": "This is the constructor for the Stack class in Python. It initializes an empty list that will act as the stack.",
        "push": "The push method appends a new element to the end of the list, representing the top of the stack.",
        "pop": "The pop method removes and returns the last element of the list. It raises an IndexError if the stack is empty.",
        "isEmpty": "The isEmpty method checks whether the stack is empty by verifying if the list has no elements.",
        "main": "This is a sample main function that demonstrates how to use the Stack class in Python by pushing elements onto the stack and then popping them off."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "template <typename T>\nStack<T>::Stack(/* args */)\n{\n    this->size = 0;\n    this->head = nullptr;\n}",
        "destructor": "template <typename T>\nStack<T>::~Stack()\n{\n    while (!this->isEmpty())\n        T item = this->pop();\n}",
        "push": "template <typename T>\nvoid Stack<T>::push(T value)\n{\n    Node<T> *new_head = new Node<T>(value);\n    new_head->prev = this->head;\n    this->head = new_head;\n    this->size++;\n}",
        "pop": "template <typename T>\nT Stack<T>::pop()\n{\n    if (this->isEmpty()) throw std::out_of_range(\"Stack is empty\");\n    T value = this->head->value;\n    Node<T> *old_head = this->head;\n    this->head = old_head->prev;\n    delete old_head;\n    this->size--;\n    return value;\n}",
        "isEmpty": "template <typename T>\nbool Stack<T>::isEmpty()\n{\n    return this->head == nullptr;\n}",
        "main": "#include <iostream>\n#include <string>\n#include <vector>\n#include 'Stack.h'\n\nusing namespace std;\n\nint main()\n{\n    Stack<string> stack = Stack<string>();\n    vector<string> sampleVec = {\"This\",\"is\",\"a\",\"sample\",\"vector\"};\n    cout << stack.isEmpty() << endl;\n    for (int i = 0; i < sampleVec.size(); i++)\n{\n        cout << \"Push: \" << sampleVec[i] << endl;\n        stack.push(sampleVec[i]);\n}"
      },
      "Python": {
        "constructor": "class Stack:\n    def __init__(self):\n        self.items = []",
        "destructor": "def __del__(self):\n        print(\"Stack is being deleted\")",
        "push": "def push(self, item):\n    self.items.append(item)",
        "pop": "def pop(self):\n    if not self.isEmpty():\n        return self.items.pop()\n    raise IndexError('pop from empty stack')",
        "isEmpty": "def isEmpty(self):\n    return len(self.items) == 0",
        "main": "if __name__ == '__main__':\n    stack = Stack()\n    stack.push(1)\n    stack.push(2)\n    print(stack.pop())\n    print(stack.isEmpty())"
      }
    },
    "comments": []
  },
  {
    "id": 2,
    "title": "Linked Lists Explained: From Basics to Advanced",
    "description": "Explore linked lists, a versatile data structure that allows for dynamic memory allocation, with clear examples and comparisons to arrays in C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-09-26",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, linked lists can be implemented using pointers and structs or classes. A linked list consists of nodes where each node contains data and a pointer to the next node. Common operations include insertion, deletion, and traversal."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the LinkedList class. It initializes an empty linked list with the head pointer set to `nullptr`.",
        "destructor": "This is the destructor for the LinkedList class. It deallocates all the nodes in the list to free memory, ensuring no memory leaks occur.",
        "insert": "The insert method adds a new node with the specified value to the end of the list. It traverses the list and links the new node to the last node.",
        "deleteNode": "The deleteNode method removes the node with the given value. It adjusts the links between nodes to maintain the integrity of the list, deleting the node when found.",
        "print": "The print method traverses the linked list and prints each node’s data in sequence, separated by arrows ('->') to represent the links between them.",
        "main": "This is the main function, which demonstrates how to create a linked list, insert nodes, delete nodes, and print the list."
      },
      "Python": {
        "constructor": "This is the constructor for the LinkedList class in Python. It initializes an empty linked list with the head pointer set to None.",
        "destructor": "This is the destructor for the LinkedList class in Python. Although Python has automatic garbage collection, this method can be implemented to explicitly free memory if needed.",
        "insert": "The insert method adds a new node with the specified value at the end of the linked list. It checks if the head is None and updates it accordingly, or traverses to the last node to link the new node.",
        "delete": "The delete method removes the first node that contains the specified value. It handles cases where the node to delete is the head or a node further down the list.",
        "print": "The printList method traverses the linked list and prints each node’s data in sequence, separated by arrows ('->'). It provides a visual representation of the links between nodes.",
        "main": "This is the main function, which demonstrates how to create a linked list in Python, insert nodes, delete nodes, and print the list."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "// Template struct for Node\ntemplate <typename T>\nstruct Node\n{\n    T data;     // Data stored in the node\n    Node<T> *prev; // Pointer to the next node\n\n    // Constructor to initialize the node\n    Node<T>(T value) : data(value), prev(nullptr) {}\n};\n\ntemplate <typename T>\nLinkedList<T>::LinkedList()\n{\n    this->head = nullptr;\n}\n\n// Initializes the head to nullptr, indicating an empty list.",
        "destructor": "template <typename T>\nLinkedList<T>::~LinkedList()\n{\n    Node<T> *temp;\n    while (head) {\n        temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\n// Frees memory by deleting all nodes in the list.",
        "insert": "template <typename T>\nvoid LinkedList<T>::insert(T val)\n{\n    Node<T> *newNode = new Node<T>(val);\n    if (!head) {\n        head = newNode;\n    } else {\n        Node<T> *temp = head;\n        while (temp->next) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n}\n\n// Inserts a new node with the value `val` at the end of the list.",
        "delete": "template <typename T>\nbool LinkedList<T>::deleteNode(T val)\n{\n    if (!head) return false;\n    if (head->data == val) {\n        Node<T> *temp = head;\n        head = head->next;\n        delete temp;\n        return true;\n    }\n    Node<T> *temp = head;\n    while (temp->next) {\n        if (temp->next->data == val) {\n            Node<T> *nodeToDelete = temp->next;\n            temp->next = temp->next->next;\n            delete nodeToDelete;\n            return true;\n        }\n        temp = temp->next;\n    }\n    return false;\n}\n\n// Deletes the node with the given value `val`.",
        "print": "template <typename T>\nvoid LinkedList<T>::print()\n{\n    Node<T> *temp = head;\n    while (temp) {\n        std::cout << temp->data;\n        if (temp->next != nullptr)\n            std::cout << \" -> \";\n        temp = temp->next;\n    }\n    std::cout << std::endl;\n}\n\n// Prints the linked list by traversing from head to the last node.",
        "main": "#include <iostream>\n#include \"LinkedList.h\"\n\nint main()\n{\n    LinkedList<int> linkedList;\n    linkedList.insert(1);\n    linkedList.insert(2);\n    linkedList.insert(3);\n    linkedList.print();\n\n    linkedList.deleteNode(1);\n    linkedList.print();\n    linkedList.deleteNode(2);\n    linkedList.print();\n    linkedList.deleteNode(3);\n    linkedList.print();\n    return 0;\n}\n\n// Demonstrates inserting, deleting, and printing nodes in the linked list."
      },
      "Python": {
        "constructor": "class Node:\n    def __init__(self, value) -> None:\n        self.data: int = value  # Store the data value\n        self.next: 'Node' = None  # Initialize the next pointer to None\n\nclass LinkedList:\n    def __init__(self) -> None:\n        self.head: Node = None  # Initialize the head to None, indicating an empty list.",
        "destructor": "def __del__(self):\n    \"\"\"Destructor to clean up nodes when the list is no longer needed.\"\"\"\n    current = self.head\n    while current:\n        next_node = current.next\n        del current  # Explicitly deleting node\n        current = next_node",
        "insert": "def insert(self, val) -> None:\n        \"\"\"Inserts a new node with the specified value at the end of the list.\"\"\"\n        newNode = Node(val)\n\n        if self.head is None:\n            self.head = newNode\n        else:\n            temp = self.head\n            while temp.next:\n                temp = temp.next\n            temp.next = newNode\n\n        # Inserts a new node with the value `val` at the end of the list.",
        "delete": "def delete(self, val) -> bool:\n        \"\"\"Deletes the first node with the specified value from the list.\n        Returns True if the node was deleted, False if not found.\n        \"\"\"\n        if self.head is None:  # If the list is empty\n            return False\n\n        # Deleting the head node\n        if self.head.data == val:\n            self.head = self.head.next  # Move the head to the next node\n            return True\n\n        # Traverse the list to find the node to delete\n        current = self.head\n        while current.next:  # Ensure we're not accessing null pointers\n            if current.next.data == val:  # Node to delete found\n                current.next = current.next.next  # Bypass the node to delete it\n                return True\n            current = current.next  # Move to the next node\n\n        return False  # Value not found in the list\n\n        # Deletes the first node with the specified value `val`.",
        "print": "def printList(self):\n        temp = self.head\n        while temp:\n            print(temp.data,end=\"\")\n            if temp.next:\n                print(\" -> \",end=\"\")\n            temp = temp.next\n        print()\n\n        # Prints the linked list by traversing from head to the last node.",
        "main": "def main():\n    linked_list = LinkedList()\n    linked_list.insert(1)\n    linked_list.insert(2)\n    linked_list.insert(3)\n    linked_list.printList()  # Output: 1 -> 2 -> 3\n\n    linked_list.delete(2)\n    linked_list.printList()  # Output: 1 -> 3\n    linked_list.delete(1)\n    linked_list.printList()  # Output: 3\n    linked_list.delete(3)\n    linked_list.printList()  # Output: \n\nif __name__ == '__main__':\n    main()\n\n        # Demonstrates inserting, deleting, and printing nodes in the linked list."
      }
    },
    "comments": []
  },
  {
    "id": 3,
    "title": "Understanding Queues: FIFO Data Structures in C++ and Python",
    "description": "Dive into the details of hash tables, a fundamental data structure that provides fast lookups, insertions, and deletions using hash functions, implemented in both C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-10-01",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, a hash table can be implemented using arrays or vectors, with hash functions to map values to indices. Collision resolution techniques such as chaining or open addressing are commonly used. This implementation uses chaining with vectors to handle collisions.",
      "Python": "In Python, hash tables are abstracted by dictionaries. They are dynamic and provide average O(1) complexity for lookups, insertions, and deletions using built-in hash functions."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the HashTable class. It initializes a hash table with a specified size and sets up the table as a vector of vectors, allowing for collision handling with separate chaining.",
        "destructor": "This is the destructor for the HashTable class. It ensures that all dynamically allocated memory is properly freed when the hash table is no longer in use. The C++ vector automatically handles memory deallocation, so no explicit memory cleanup is needed.",
        "insert": "The insert method adds a value to the hash table by computing the hash value (using modulo division by the size of the table) and storing it in the appropriate bucket. If the bucket is full due to collisions, insertion fails.",
        "lookup": "The lookup method checks whether a given value exists in the hash table by computing its hash and searching through the list of elements in the corresponding bucket.",
        "main": "This main function demonstrates how to initialize the hash table, insert values, and check for the presence of values using the lookup function."
      },
      "Python": {
        "constructor": "This is the constructor for a hash table in Python. In Python, hash tables are implemented using dictionaries, so the constructor simply initializes an empty dictionary.",
        "insert": "The insert method adds a key-value pair to the dictionary, where the key is hashed automatically by Python's internal hash function. No manual collision handling is needed.",
        "lookup": "The lookup method checks for the existence of a key in the dictionary using Python's built-in `in` keyword. If the key exists, it retrieves the associated value.",
        "main": "This main function shows how to create a hash table using Python's dictionary, insert key-value pairs, and perform lookups efficiently."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "HashTable(int size) : size(size)\n{\n    table.resize(size);\n}",
        "destructor": "// Destructor (not strictly needed due to vector auto clean-up, but defined for good practice)\nHashTable::~HashTable()\n{\n    // Vector's destructor will handle the cleanup automatically, so nothing to do here\n}",
        "insert": "bool insert(const T &value)\n{\n    if(this->lookup(value))\n        return false;\n    int bucket = std::hash<T>{}(value) % size;\n    table[bucket].push_back(value);\n    return true;\n}",
        "lookup": "bool lookup(const T &value)\n{\n    int bucket = std::hash<T>{}(value) % size;\n    for (auto &elem : table[bucket])\n    {\n        if (elem == value)\n        {\n            return true;\n        }\n    }\n    return false;\n}",
        "delete": "void deleteHash(const T &value)\n{\n    int bucket = std::hash<T>{}(value) % size;\n    table[bucket].remove(value);\n}",
        "main": "#include \"HashTable.h\"\n#include <iostream>\n#include <string>\n\nint main()\n{\n    // Create a hash table with a certain size\n    HashTable<int> ht(10);\n\n    // Test inserting elements\n    std::cout << \"Inserting elements into the hash table...\" << std::endl;\n    ht.insert(1);\n    ht.insert(2);\n    ht.insert(3);\n    ht.insert(10);  // This will collide with 1 if hash function is modulo size\n\n    // Test lookup\n    std::cout << \"Looking up elements...\" << std::endl;\n    std::cout << \"Element 2 found: \" << (ht.lookup(2) ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Element 5 found: \" << (ht.lookup(5) ? \"Yes\" : \"No\") << std::endl;\n\n    // Test deletion\n    std::cout << \"Deleting element 2...\" << std::endl;\n    ht.deleteHash(2);\n    std::cout << \"Element 2 found after deletion: \" << (ht.lookup(2) ? \"Yes\" : \"No\") << std::endl;\n\n    // Re-insert and test\n    std::cout << \"Re-inserting element 2...\" << std::endl;\n    ht.insert(2);\n    std::cout << \"Element 2 found after re-inserting: \" << (ht.lookup(2) ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}"
      },
      "Python": {
        "constructor": "def __init__(self, size):\n    self.size = size\n    self.table = {}",
        "destructor": "def __del__(self):\n    print(f\"HashTable with size {self.size} is being deleted\")\n    # Any other cleanup operations can be added here",
        "insert": "def insert(self, value):\n    bucket = hash(value) % self.size\n    if bucket in self.table:\n        if value in self.table[bucket]:\n            return False\n        self.table[bucket].append(value)\n    else:\n        self.table[bucket] = [value]\n    return True",
        "lookup": "def lookup(self, value):\n    bucket = hash(value) % self.size\n    return bucket in self.table and value in self.table[bucket]",
        "delete": "def delete(self, value):\n    bucket = hash(value) % self.size\n    if bucket in self.table and value in self.table[bucket]:\n        self.table[bucket].remove(value)\n        if not self.table[bucket]:  # if the bucket is empty after removal, you might want to clean up\n            del self.table[bucket]",
        "main": "def main():\n    # Create a hash table with a certain size\n    ht = HashTable(10)\n\n        # Test inserting elements\n    print(\"Inserting elements into the hash table...\")\n    ht.insert(1)\n    ht.insert(2)\n    ht.insert(3)\n    ht.insert(10)  # This will collide with 1 if hash function is modulo size\n\n    # Test lookup\n    print(\"Looking up elements...\")\n    print(f\"Element 2 found: {'Yes' if ht.lookup(2) else 'No'}\")\n    print(f\"Element 5 found: {'Yes' if ht.lookup(5) else 'No'}\")\n\n    # Test deletion\n    print(\"Deleting element 2...\")\n    ht.delete(2)\n    print(f\"Element 2 found after deletion: {'Yes' if ht.lookup(2) else 'No'}\")\n\n    # Re-insert and test\n    print(\"Re-inserting element 2...\")\n    ht.insert(2)\n    print(f\"Element 2 found after re-inserting: {'Yes' if ht.lookup(2) else 'No'}\")\n\nif __name__ == \"__main__\":\n    main()"
      }
    },
    "comments": []
  },
  {
    "id": 4,
    "title": "Queue Data Structure Explained",
    "description": "Unpack the essentials of the Queue data structure in this detailed exploration of its implementations in C++ and Python. Learn how this straightforward, FIFO-based system efficiently manages data flows in various applications.",
    "category": "Data Structures",
    "publishDate": "2024-10-02",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "The C++ implementation of the Queue uses dynamic memory management to ensure efficient data handling. The queue supports basic operations such as enqueue, dequeue, and peek, following the FIFO principle.",
      "Python": "The Python version of the Queue is implemented using native list operations that provide simple and direct methods to manage the queue's FIFO functionality."
    },
    "descriptions": {
      "C++": {
        "constructor": "Initializes a new empty queue with allocated memory.",
        "destructor": "Frees up the memory used by the queue when it is destroyed.",
        "enqueue": "Adds an item to the end of the queue.",
        "dequeue": "Removes the item at the front of the queue.",
        "peek": "Returns the item at the front of the queue without removing it.",
        "isEmpty": "Checks if the queue is empty."
      },
      "Python": {
        "constructor": "Creates an empty queue using a Python list.",
        "enqueue": "Appends an item to the end of the list, acting as the queue's rear.",
        "dequeue": "Pops the first item of the list, representing the front of the queue.",
        "peek": "Accesses the first item of the list without removing it, showing the next item to be dequeued.",
        "isEmpty": "Returns True if the list (queue) is empty, otherwise False."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "template <typename T>\nstruct Node\n{\n    T data;\n    Node<T> *next;\n\n    Node<T>(T data) : data(data), next(nullptr) {}\n};\n\ntemplate <typename T>\nQueue<T>::Queue()\n{\n    this->front = nullptr;\n    this->rear = nullptr;\n}",
        "destructor": "template <typename T>\nQueue<T>::~Queue()\n{\n    while (this->front != nullptr)\n    {\n        this->dequeue();\n    }\n}",
        "enqueue": "template <typename T>\nvoid Queue<T>::enqueue(T value)\n{\n    Node<T> *newNode = new Node<T>(value);\n    if (this->isEmpty())\n    {\n        this->front = this->rear = newNode;\n    }\n    else\n    {\n        this->rear->next = newNode;\n        this->rear = newNode;\n    }\n}",
        "dequeue": "template <typename T>\nvoid Queue<T>::dequeue()\n{\n    if (!this->isEmpty())\n    {\n        Node<T> *temp = this->front;\n        this->front = this->front->next;\n        if (this->front == nullptr)\n        {\n            this->rear = nullptr;\n        }\n        delete temp;\n    }\n}",
        "peek": "template <typename T>\nT Queue<T>::peek()\n{\n    return (!this->isEmpty()) ? this->front->data : -1;\n}",
        "isEmpty": "template <typename T>\nbool Queue<T>::isEmpty()\n{\n    return this->front == nullptr;\n}",
        "main": "#include <iostream>\n#include \"Queue.h\"\n\nint main() {\nQueue<int> *q = new Queue<int>();  // Create a queue for integers\n\n    std::cout << \"Enqueuing elements{1,2,3,4}...\" << std::endl;\n    q->enqueue(1);\n    q->enqueue(2);\n    q->enqueue(3);\n\n    std::cout << \"Current front element: \" << q->peek() << std::endl;  // Should print 1\n\n    std::cout << \"Dequeuing...\" << std::endl;\n    q->dequeue();\n    std::cout << \"New front element after one dequeue: \" << q->peek() << std::endl;  // Should print 2\n\n    std::cout << \"Checking if queue is empty: \" << (q->isEmpty() ? \"Yes\" : \"No\") << std::endl;  // Should print No\n\n    std::cout << \"Dequeuing remaining elements...\" << std::endl;\n    q->dequeue();\n    q->dequeue();  // Queue should be empty after this\n\n    std::cout << \"Checking if queue is empty after dequeuing all elements: \" << (q->isEmpty() ? \"Yes\" : \"No\") << std::endl;  // Should print Yes\n\n    try {\n        std::cout << \"Attempting to peek into an empty queue: \";\n        std::cout << q->peek() << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cout << e.what() << std::endl;  // Should catch and print \"Queue is empty\"\n    }\n\n    return 0;\n}"
      },
      "Python": {
        "constructor": "class Queue:\n    def __init__(self, capacity=None):\n        self.capacity = capacity\n        self.q = []",
        "enqueue": "def enqueue(self, value):\n    if self.capacity is not None and len(self.q) >= self.capacity:\n        raise RuntimeError(\"Queue is full\")\n    self.q.append(value)",
        "dequeue": "def dequeue(self):\n    if not self.isEmpty():\n        return self.q.pop(0)\n    return \"Queue is empty\"",
        "peek": "def peek(self):\n    if self.isEmpty():\n        return \"Queue is empty\"\n    return self.q[0]",
        "isEmpty": "def isEmpty(self):\n    return len(self.q) == 0",
        "main": "def main():\n    q = Queue()  # Create a queue for integers\n    print(\"Enqueuing elements{1,2,3,4}...\")\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    q.enqueue(4)  # This was not included in your original C++ enqueuing, but added as per the printed message\n\n    print(f\"Current front element: {q.peek()}\")  # Should print 1\n\n    print(\"Dequeuing...\")\n    q.dequeue()\n    print(f\"New front element after one dequeue: {q.peek()}\")  # Should print 2\n\n    print(f\"Checking if queue is empty: {'Yes' if q.isEmpty() else 'No'}\")  # Should print No\n\n    print(\"Dequeuing remaining elements...\")\n    q.dequeue()\n    q.dequeue()\n    q.dequeue()  # Added one more dequeue to empty the queue after adding 4th element\n\n    print(f\"Checking if queue is empty after dequeuing all elements: {'Yes' if q.isEmpty() else 'No'}\")  # Should print Yes\n\n    try:\n        print(\"Attempting to peek into an empty queue: \", end=\"\")\n        print(q.peek())\n    except IndexError as e:\n        print(e)  # Should catch and print \"Queue is empty\"\n\nif __name__ == \"__main__\":\n    main()"
      }
    },
    "comments": []
  }
]
